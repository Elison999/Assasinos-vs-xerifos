-- Bridge Hub MM2 Space GUI Script - PARTE 1
-- Criado para Roblox

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Criar ScreenGui principal
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BridgeHubSpaceGUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Frame principal com fundo espacial
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(1, 0, 1, 0)
mainFrame.Position = UDim2.new(0, 0, 0, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 30)
mainFrame.BorderSizePixel = 0
mainFrame.BackgroundTransparency = 1
mainFrame.Parent = screenGui

-- Gradiente espacial
local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(20, 20, 60)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(40, 10, 80)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(10, 10, 30))
}
gradient.Rotation = 45
gradient.Parent = mainFrame

-- Criar estrelas animadas no fundo
local function createStar(parent)
    local star = Instance.new("Frame")
    star.Size = UDim2.new(0, math.random(2, 6), 0, math.random(2, 6))
    star.Position = UDim2.new(math.random(0, 100)/100, 0, math.random(0, 100)/100, 0)
    star.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    star.BorderSizePixel = 0
    star.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = star
    
    local twinkle = TweenService:Create(
        star,
        TweenInfo.new(math.random(1, 3), Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
        {BackgroundTransparency = math.random(30, 80)/100}
    )
    twinkle:Play()
    
    return star
end

-- Adicionar múltiplas estrelas
for i = 1, 50 do
    createStar(mainFrame)
end

-- Texto principal
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "TitleLabel"
titleLabel.Size = UDim2.new(0, 600, 0, 100)
titleLabel.Position = UDim2.new(0.5, -300, 0.5, -50)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Bridge Hub Assasinos vs Xerifos"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 48
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextStrokeTransparency = 0.5
titleLabel.TextStrokeColor3 = Color3.fromRGB(100, 150, 255)
titleLabel.Parent = mainFrame

-- Gradiente no texto
local textGradient = Instance.new("UIGradient")
textGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(150, 200, 255)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(200, 150, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 200, 150))
}
textGradient.Parent = titleLabel

-- Animação do gradiente
local gradientTween = TweenService:Create(
    textGradient,
    TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
    {Rotation = 360}
)

-- Criar partículas
local function createParticle()
    local particle = Instance.new("Frame")
    particle.Size = UDim2.new(0, math.random(1, 3), 0, math.random(1, 3))
    particle.Position = UDim2.new(math.random(0, 100)/100, 0, 1.1, 0)
    particle.BackgroundColor3 = Color3.fromRGB(
        math.random(150, 255),
        math.random(150, 255),
        math.random(200, 255)
    )
    particle.BorderSizePixel = 0
    particle.Parent = mainFrame
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = particle
    
    local moveTween = TweenService:Create(
        particle,
        TweenInfo.new(math.random(3, 6), Enum.EasingStyle.Linear),
        {Position = UDim2.new(particle.Position.X.Scale, 0, -0.1, 0)}
    )
    
    moveTween:Play()
    moveTween.Completed:Connect(function()
        particle:Destroy()
    end)
end

-- Gerar partículas
local particleConnection = RunService.Heartbeat:Connect(function()
    if math.random(1, 30) == 1 then
        createParticle()
    end
end)

-- Animações de entrada
local fadeInTween = TweenService:Create(
    mainFrame,
    TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
    {BackgroundTransparency = 0}
)

local textFadeIn = TweenService:Create(
    titleLabel,
    TweenInfo.new(1.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
    {
        TextTransparency = 0,
        Position = UDim2.new(0.5, -300, 0.5, -50)
    }
)

titleLabel.TextTransparency = 1
titleLabel.Position = UDim2.new(0.5, -300, 0.7, -50)

fadeInTween:Play()
textFadeIn:Play()
gradientTween:Play()

-- Animação de saída após 5 segundos
wait(5)

particleConnection:Disconnect()
gradientTween:Pause()

local fadeOutTween = TweenService:Create(
    mainFrame,
    TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
    {BackgroundTransparency = 1}
)

local textFadeOut = TweenService:Create(
    titleLabel,
    TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
    {
        TextTransparency = 1,
        Position = UDim2.new(0.5, -300, 0.3, -50)
    }
)

fadeOutTween:Play()
textFadeOut:Play()

fadeOutTween.Completed:Connect(function()
    screenGui:Destroy()
end)

print("Bridge Hub MM2 - Space GUI carregada - Parte 1 completa!")

-- Bridge Hub MM2 Script - PARTE 2
-- Variáveis e Funções Principais

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Camera = Workspace.CurrentCamera

-- Variáveis Globais
local detectorEnabled = false
local antiHackerEnabled = false
local maxNormalSpeed = 23
local detectedHackers = {}
local platform = nil
local connection = nil

local ESPEnabled = false
local AimbotEnabled = false
local AutoShootEnabled = false
local PingPredictionEnabled = false
local PingMS = 100
local FOVRadius = 100
local targetPlayer = nil
local espConnections = {}
local fovCircle = nil
local aimButton = nil
local ShootType = "Normal"

local hitboxEnabled = false
local hitboxSize = 5
local hitboxTransparency = 0.8
local connections = {}
local hitboxParts = {}

local speedEnabled = false
local playerSpeed = 16

local autoKnifeEnabled = false
local autoKillEnabled = false

local originalCFrame = Camera.CFrame
local isSpectating = false
local currentPlayerIndex = 1
local spectatingConnection
local playersToSpectate = {}
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

local playerNameGui
local leftButton
local rightButton
local exitButton

-- Criar GUI Principal
local Window = Rayfield:CreateWindow({
    Name = "Assasinos vs xerifos - Bridge Hub",
    LoadingTitle = "Loading",
    LoadingSubtitle = "by darker9899",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "ESPAimbot",
        FileName = "config"
    },
    Discord = {
        Enabled = false
    },
    KeySystem = false
})

local MainTab = Window:CreateTab("Main", 4483362458)
local HitboxTab = Window:CreateTab("Hitbox", 4483362458)
local TeamTab = Window:CreateTab("Anti enemys + team check", 4483362458)
local AntiHackerTab = Window:CreateTab("Anti-Hacker", 4483362458)
local PlayerTab = Window:CreateTab("Player", 4483362458)
local KnifeTab = Window:CreateTab("Knife", 4483362458)

-- Funções de Hitbox
local function createHitbox(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local character = player.Character
    local humanoidRootPart = character.HumanoidRootPart
    
    if hitboxParts[player] then
        hitboxParts[player]:Destroy()
        hitboxParts[player] = nil
    end
    
    local hitbox = Instance.new("Part")
    hitbox.Name = "ExpandedHitbox"
    hitbox.Anchored = true
    hitbox.CanCollide = false
    hitbox.Material = Enum.Material.ForceField
    hitbox.BrickColor = BrickColor.new("Really red")
    hitbox.Transparency = hitboxTransparency
    hitbox.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    hitbox.Shape = Enum.PartType.Ball
    hitbox.TopSurface = Enum.SurfaceType.Smooth
    hitbox.BottomSurface = Enum.SurfaceType.Smooth
    hitbox.Parent = workspace
    
    hitboxParts[player] = hitbox
    
    local connection
    connection = RunService.Heartbeat:Connect(function()
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and hitbox.Parent then
            hitbox.CFrame = player.Character.HumanoidRootPart.CFrame
        else
            connection:Disconnect()
            if hitboxParts[player] == hitbox then
                hitboxParts[player] = nil
            end
        end
    end)
    
    connections[player] = connection
end

local function removeHitbox(player)
    if hitboxParts[player] then
        hitboxParts[player]:Destroy()
        hitboxParts[player] = nil
    end
    if connections[player] then
        connections[player]:Disconnect()
        connections[player] = nil
    end
end

local function updateAllHitboxes()
    if not hitboxEnabled then return end
    
    for player, hitbox in pairs(hitboxParts) do
        if hitbox and hitbox.Parent then
            hitbox.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
            hitbox.Transparency = hitboxTransparency
        end
    end
end

local function enableHitboxes()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            createHitbox(player)
        end
    end
end

local function disableHitboxes()
    for player, _ in pairs(hitboxParts) do
        removeHitbox(player)
    end
end

-- Funções de ESP
local function createESP(player)
    if player == LocalPlayer or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local character = player.Character
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESPHighlight"
    highlight.Adornee = character
    highlight.FillColor = Color3.fromRGB(173, 216, 230)
    highlight.FillTransparency = 0.8
    highlight.OutlineColor = Color3.fromRGB(173, 216, 230)
    highlight.OutlineTransparency = 0
    highlight.Parent = character
    
    return highlight
end

local function removeESP(player)
    if player.Character and player.Character:FindFirstChild("ESPHighlight") then
        player.Character.ESPHighlight:Destroy()
    end
end

local function updateESPColor(player, color)
    if player.Character and player.Character:FindFirstChild("ESPHighlight") then
        local highlight = player.Character.ESPHighlight
        highlight.FillColor = color
        highlight.OutlineColor = color
    end
end

-- Funções de Aimbot
local function isPlayerInFOV(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local character = player.Character
    local humanoidRootPart = character.HumanoidRootPart
    local screenPos, onScreen = Camera:WorldToViewportPoint(humanoidRootPart.Position)
    
    if not onScreen then
        return false
    end
    
    local centerX, centerY = Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2
    local distance = math.sqrt((screenPos.X - centerX)^2 + (screenPos.Y - centerY)^2)
    
    return distance <= FOVRadius
end

local function getPredictedPosition(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end
    
    local humanoidRootPart = player.Character.HumanoidRootPart
    
    if not PingPredictionEnabled then
        return humanoidRootPart.Position
    end
    
    local velocity = humanoidRootPart.AssemblyLinearVelocity
    
    if velocity.Magnitude < 1 then
        return humanoidRootPart.Position
    end
    
    local predictionTime = PingMS / 1000
    local currentPosition = humanoidRootPart.Position
    local predictedPosition = currentPosition + (velocity * predictionTime)
    
    return predictedPosition
end

local function hasLineOfSight(targetPosition)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local origin = LocalPlayer.Character.HumanoidRootPart.Position
    local direction = (targetPosition - origin).Unit * (targetPosition - origin).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    
    local raycastResult = Workspace:Raycast(origin, direction, raycastParams)
    
    if raycastResult then
        local hit = raycastResult.Instance
        local hitCharacter = hit.Parent
        
        if hitCharacter and hitCharacter:FindFirstChild("Humanoid") then
            local player = Players:GetPlayerFromCharacter(hitCharacter)
            if player and targetPlayer and player == targetPlayer then
                return true
            end
        end
    end
    
    return false
end

local function pullPlayerToPosition(player, position)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(position)
    end
end

local function shootAtPosition(targetPosition)
    local currentTool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if currentTool and currentTool:FindFirstChild("GunServer") and currentTool.GunServer:FindFirstChild("GunStart") then
        local args = {
            [1] = 1,
            [2] = targetPosition
        }
        currentTool.GunServer.GunStart:FireServer(unpack(args))
        return true
    end
    return false
end

local function executeAutoShoot()
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local targetPosition = getPredictedPosition(targetPlayer)
        if not targetPosition then return false end
        
        local currentPosition = targetPlayer.Character.HumanoidRootPart.Position
        if hasLineOfSight(currentPosition) then
            return shootAtPosition(targetPosition)
        end
    end
    return false
end

local function getClosestPlayerInFOV()
    local closestPlayer = nil
    local closestDistance = math.huge
    local centerX, centerY = Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if isPlayerInFOV(player) then
                local screenPos = Camera:WorldToViewportPoint(player.Character.HumanoidRootPart.Position)
                local distance = math.sqrt((screenPos.X - centerX)^2 + (screenPos.Y - centerY)^2)
                
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end
    
    return closestPlayer
end

print("Bridge Hub MM2 - Parte 2 completa!")

-- Bridge Hub MM2 Script - PARTE 3
-- GUI Elements e Toggles

-- Função para criar círculo FOV
local function createFOVCircle()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "FOVCircleGui"
    screenGui.Parent = CoreGui
    screenGui.ResetOnSpawn = false
    
    local circle = Instance.new("Frame")
    circle.Name = "FOVCircle"
    circle.AnchorPoint = Vector2.new(0.5, 0.5)
    circle.Position = UDim2.new(0.5, 0, 0.5, 0)
    circle.Size = UDim2.new(0, FOVRadius * 2, 0, FOVRadius * 2)
    circle.BackgroundTransparency = 1
    circle.Parent = screenGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = circle
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(255, 255, 255)
    stroke.Thickness = 2
    stroke.Transparency = 0.5
    stroke.Parent = circle
    
    return screenGui
end

-- Função para criar botão de aim
local function createAimButton()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AimButtonGui"
    screenGui.Parent = CoreGui
    screenGui.ResetOnSpawn = false
    
    local button = Instance.new("TextButton")
    button.Name = "AimButton"
    button.Size = UDim2.new(0, 120, 0, 120)
    button.Position = UDim2.new(1, -140, 0.5, -60)
    button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    button.Text = "AIM"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextScaled = true
    button.Font = Enum.Font.SourceSansBold
    button.Parent = screenGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = button
    
    local dragging = false
    local dragStart = nil
    local startPos = nil
    
    button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = button.Position
        end
    end)
    
    button.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    
    button.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)
    
    button.MouseButton1Click:Connect(function()
        if ShootType == "100% (Grab)" then
            -- Modo Grab: Puxa o jogador e atira
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local myPos = LocalPlayer.Character.HumanoidRootPart.Position
                local pullPos = myPos + (Camera.CFrame.LookVector * 5)
                pullPlayerToPosition(targetPlayer, pullPos)
                wait(0.1)
                local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
                shootAtPosition(targetPosition)
            end
        else
            -- Modo Normal
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local targetPosition = getPredictedPosition(targetPlayer)
                if targetPosition then
                    shootAtPosition(targetPosition)
                end
            end
        end
    end)
    
    return screenGui
end

-- MAIN TAB TOGGLES E SLIDERS
local ESPToggle = MainTab:CreateToggle({
    Name = "Esp",
    CurrentValue = false,
    Flag = "ESP",
    Callback = function(Value)
        ESPEnabled = Value
        
        if ESPEnabled then
            local function updateAllESP()
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer then
                        removeESP(player)
                        createESP(player)
                    end
                end
            end
            
            updateAllESP()
            
            espConnections.ESPUpdateLoop = task.spawn(function()
                while ESPEnabled do
                    wait(2)
                    if ESPEnabled then
                        updateAllESP()
                    end
                end
            end)
            
            espConnections.PlayerAdded = Players.PlayerAdded:Connect(function(player)
                if ESPEnabled then
                    player.CharacterAdded:Connect(function()
                        wait(1)
                        createESP(player)
                    end)
                end
            end)
            
            espConnections.PlayerRemoving = Players.PlayerRemoving:Connect(function(player)
                removeESP(player)
            end)
        else
            for _, player in pairs(Players:GetPlayers()) do
                removeESP(player)
            end
            
            for name, connection in pairs(espConnections) do
                if name == "ESPUpdateLoop" then
                    task.cancel(connection)
                else
                    connection:Disconnect()
                end
            end
            espConnections = {}
        end
    end,
})

local ShootTypeDropdown = MainTab:CreateDropdown({
    Name = "Shoot Type",
    Options = {"Normal", "100% (Grab)"},
    CurrentOption = "Normal",
    Flag = "ShootType",
    Callback = function(Option)
        ShootType = Option
    end,
})

local AimbotToggle = MainTab:CreateToggle({
    Name = "Shoot button + Fov",
    CurrentValue = false,
    Flag = "Aimbot",
    Callback = function(Value)
        AimbotEnabled = Value
        
        if AimbotEnabled then
            fovCircle = createFOVCircle()
            aimButton = createAimButton()
            
            espConnections.AimbotLoop = RunService.Heartbeat:Connect(function()
                if AimbotEnabled and ESPEnabled then
                    local closestPlayer = getClosestPlayerInFOV()
                    
                    for _, player in pairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer then
                            updateESPColor(player, Color3.fromRGB(173, 216, 230))
                        end
                    end
                    
                    if closestPlayer then
                        targetPlayer = closestPlayer
                        updateESPColor(closestPlayer, Color3.fromRGB(255, 0, 0))
                        
                        if AutoShootEnabled and ShootType == "Normal" then
                            executeAutoShoot()
                        end
                    else
                        targetPlayer = nil
                    end
                end
            end)
        else
            if fovCircle then
                fovCircle:Destroy()
                fovCircle = nil
            end
            if aimButton then
                aimButton:Destroy()
                aimButton = nil
            end
            if espConnections.AimbotLoop then
                espConnections.AimbotLoop:Disconnect()
                espConnections.AimbotLoop = nil
            end
            targetPlayer = nil
            
            if ESPEnabled then
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer then
                        updateESPColor(player, Color3.fromRGB(173, 216, 230))
                    end
                end
            end
        end
    end,
})

local PingToggle = MainTab:CreateToggle({
    Name = "Ping Prediction",
    CurrentValue = false,
    Flag = "PingPrediction",
    Callback = function(Value)
        PingPredictionEnabled = Value
    end,
})

local PingSlider = MainTab:CreateSlider({
    Name = "Ping (MS)",
    Range = {50, 2000},
    Increment = 5,
    CurrentValue = 100,
    Flag = "PingMS",
    Callback = function(Value)
        PingMS = Value
    end,
})

local AutoShootToggle = MainTab:CreateToggle({
    Name = "Auto Shoot (Only Normal Mode)",
    CurrentValue = false,
    Flag = "AutoShoot",
    Callback = function(Value)
        AutoShootEnabled = Value
    end,
})

local FOVSlider = MainTab:CreateSlider({
    Name = "Fov Size",
    Range = {50, 300},
    Increment = 10,
    CurrentValue = 100,
    Flag = "FOVSize",
    Callback = function(Value)
        FOVRadius = Value
        
        if fovCircle and fovCircle:FindFirstChild("FOVCircle") then
            fovCircle.FOVCircle.Size = UDim2.new(0, FOVRadius * 2, 0, FOVRadius * 2)
        end
    end,
})

-- HITBOX TAB
local HitboxToggle = HitboxTab:CreateToggle({
    Name = "Enable Expanded Hitbox",
    CurrentValue = false,
    Flag = "HitboxToggle",
    Callback = function(Value)
        hitboxEnabled = Value
        if hitboxEnabled then
            enableHitboxes()
        else
            disableHitboxes()
        end
    end,
})

local SizeSlider = HitboxTab:CreateSlider({
    Name = "Hitbox Size",
    Range = {1, 20},
    Increment = 0.5,
    Suffix = " studs",
    CurrentValue = 5,
    Flag = "HitboxSize",
    Callback = function(Value)
        hitboxSize = Value
        updateAllHitboxes()
    end,
})

local TransparencySlider = HitboxTab:CreateSlider({
    Name = "Hitbox Transparency",
    Range = {0, 1},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = 0.8,
    Flag = "HitboxTransparency",
    Callback = function(Value)
        hitboxTransparency = Value
        updateAllHitboxes()
    end,
})

-- PLAYER TAB
local SpeedToggle = PlayerTab:CreateToggle({
    Name = "Speed Hack",
    CurrentValue = false,
    Flag = "SpeedToggle",
    Callback = function(Value)
        speedEnabled = Value
        if speedEnabled then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.WalkSpeed = playerSpeed
            end
        else
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.WalkSpeed = 16
            end
        end
    end,
})

local SpeedSlider = PlayerTab:CreateSlider({
    Name = "Speed Value",
    Range = {16, 200},
    Increment = 1,
    Suffix = " studs/s",
    CurrentValue = 16,
    Flag = "SpeedValue",
    Callback = function(Value)
        playerSpeed = Value
        if speedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            LocalPlayer.Character.Humanoid.WalkSpeed = playerSpeed
        end
    end,
})

-- KNIFE TAB
local AutoKnifeToggle = KnifeTab:CreateToggle({
    Name = "Auto Knife All Players",
    CurrentValue = false,
    Flag = "AutoKnifeToggle",
    Callback = function(Value)
        autoKnifeEnabled = Value
        
        if autoKnifeEnabled then
            espConnections.AutoKnifeLoop = RunService.Heartbeat:Connect(function()
                if autoKnifeEnabled then
                    local currentTool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
                    if currentTool then
                        for _, player in pairs(Players:GetPlayers()) do
                            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                local myPos = LocalPlayer.Character.HumanoidRootPart.Position
                                local pullPos = myPos + Vector3.new(0, 0, 3)
                                pullPlayerToPosition(player, pullPos)
                                wait(0.05)
                            end
                        end
                    end
                end
            end)
        else
            if espConnections.AutoKnifeLoop then
                espConnections.AutoKnifeLoop:Disconnect()
                espConnections.AutoKnifeLoop = nil
            end
        end
    end,
})

local AutoKillToggle = KnifeTab:CreateToggle({
    Name = "Auto Kill (Click + FOV)",
    CurrentValue = false,
    Flag = "AutoKillToggle",
    Callback = function(Value)
        autoKillEnabled = Value
        
        if autoKillEnabled then
            espConnections.AutoKillInput = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if gameProcessed then return end
                
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    if autoKillEnabled and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local currentTool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
                        if currentTool then
                            local originalPos = targetPlayer.Character.HumanoidRootPart.CFrame
                            local myPos = LocalPlayer.Character.HumanoidRootPart.Position
                            local pullPos = myPos + (Camera.CFrame.LookVector * 3)
                            
                            pullPlayerToPosition(targetPlayer, pullPos)
                            wait(0.2)
                            targetPlayer.Character.HumanoidRootPart.CFrame = originalPos
                        end
                    end
                end
            end)
        else
            if espConnections.AutoKillInput then
                espConnections.AutoKillInput:Disconnect()
                espConnections.AutoKillInput = nil
            end
        end
    end,
})

-- ANTI-HACKER TAB
local AntiHackerToggle = AntiHackerTab:CreateToggle({
    Name = "Anti-Hacker System",
    CurrentValue = false,
    Flag = "AntiHackerToggle",
    Callback = function(Value)
        antiHackerEnabled = Value
        
        if Value then
            connection = RunService.Heartbeat:Connect(function()
                if not antiHackerEnabled then return end
                
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") then
                        local humanoid = player.Character.Humanoid
                        local humanoidRootPart = player.Character.HumanoidRootPart
                        
                        if humanoid.WalkSpeed > maxNormalSpeed or humanoidRootPart.AssemblyLinearVelocity.Magnitude > maxNormalSpeed then
                            Rayfield:Notify({
                                Title = "Hacker Detected",
                                Content = player.Name .. " is speed hacking!",
                                Duration = 3,
                                Image = 4483362458,
                            })
                        end
                    end
                end
            end)
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end,
})

-- TEAM TAB
local TeamDetectorToggle = TeamTab:CreateToggle({
    Name = "Anti enemys + team check",
    CurrentValue = false,
    Flag = "DetectorToggle",
    Callback = function(Value)
        detectorEnabled = Value
        
        if detectorEnabled then
            connection = RunService.Heartbeat:Connect(function()
                if not detectorEnabled then return end
                
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local localPosition = LocalPlayer.Character.HumanoidRootPart.Position
                    
                    for _, player in pairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            local distance = (player.Character.HumanoidRootPart.Position - localPosition).Magnitude
                            
                            if distance <= 17.5 then
                                local isEnemy = true
                                if player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team then
                                    isEnemy = false
                                end
                                
                                if isEnemy then
                                    local currentCFrame = LocalPlayer.Character.HumanoidRootPart.CFrame
                                    local backwardDirection = -currentCFrame.LookVector
                                    local newPosition = localPosition + (backwardDirection * 1)
                                    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(newPosition, newPosition + currentCFrame.LookVector)
                                    break
                                end
                            end
                        end
                    end
                end
            end)
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end,
})

-- Event Connections
Players.PlayerAdded:Connect(function(player)
    if hitboxEnabled and player ~= LocalPlayer then
        player.CharacterAdded:Connect(function()
            wait(1)
            if hitboxEnabled then
                createHitbox(player)
            end
        end)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    removeHitbox(player)
end)

for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function()
            wait(1)
            if hitboxEnabled then
                createHitbox(player)
            end
        end)
    end
end

LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    
    if speedEnabled then
        Humanoid.WalkSpeed = playerSpeed
    end
end)

Rayfield:Notify({
    Title = "System Loaded",
    Content = "Bridge Hub loaded successfully!",
    Duration = 5,
    Image = 4483362458,
})

print("Bridge Hub MM2 - Parte 3 completa! Script totalmente carregado!")
