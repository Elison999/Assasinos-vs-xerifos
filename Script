-- Bridge Hub MM2 Complete Script - PARTE 1
-- GUI de Introdu√ß√£o Espacial + Inicializa√ß√£o de Servi√ßos
-- Criado para Roblox Murder Mystery 2

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Criar ScreenGui principal
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BridgeHubSpaceGUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Frame principal com fundo espacial
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(1, 0, 1, 0)
mainFrame.Position = UDim2.new(0, 0, 0, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 30)
mainFrame.BorderSizePixel = 0
mainFrame.BackgroundTransparency = 1
mainFrame.Parent = screenGui

-- Gradiente espacial
local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(20, 20, 60)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(40, 10, 80)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(10, 10, 30))
}
gradient.Rotation = 45
gradient.Parent = mainFrame

-- Criar estrelas animadas no fundo
local function createStar(parent)
    local star = Instance.new("Frame")
    star.Size = UDim2.new(0, math.random(2, 6), 0, math.random(2, 6))
    star.Position = UDim2.new(math.random(0, 100)/100, 0, math.random(0, 100)/100, 0)
    star.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    star.BorderSizePixel = 0
    star.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = star
    
    local twinkle = TweenService:Create(
        star,
        TweenInfo.new(math.random(1, 3), Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
        {BackgroundTransparency = math.random(30, 80)/100}
    )
    twinkle:Play()
    
    return star
end

-- Adicionar m√∫ltiplas estrelas
for i = 1, 50 do
    createStar(mainFrame)
end

-- Texto principal
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "TitleLabel"
titleLabel.Size = UDim2.new(0, 600, 0, 100)
titleLabel.Position = UDim2.new(0.5, -300, 0.5, -50)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Bridge Hub Assasinos vs Xerifos"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 48
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextStrokeTransparency = 0.5
titleLabel.TextStrokeColor3 = Color3.fromRGB(100, 150, 255)
titleLabel.Parent = mainFrame

-- Gradiente no texto
local textGradient = Instance.new("UIGradient")
textGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(150, 200, 255)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(200, 150, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 200, 150))
}
textGradient.Parent = titleLabel

-- Anima√ß√£o do gradiente
local gradientTween = TweenService:Create(
    textGradient,
    TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
    {Rotation = 360}
)

-- Criar part√≠culas
local function createParticle()
    local particle = Instance.new("Frame")
    particle.Size = UDim2.new(0, math.random(1, 3), 0, math.random(1, 3))
    particle.Position = UDim2.new(math.random(0, 100)/100, 0, 1.1, 0)
    particle.BackgroundColor3 = Color3.fromRGB(
        math.random(150, 255),
        math.random(150, 255),
        math.random(200, 255)
    )
    particle.BorderSizePixel = 0
    particle.Parent = mainFrame
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = particle
    
    local moveTween = TweenService:Create(
        particle,
        TweenInfo.new(math.random(3, 6), Enum.EasingStyle.Linear),
        {Position = UDim2.new(particle.Position.X.Scale, 0, -0.1, 0)}
    )
    
    moveTween:Play()
    moveTween.Completed:Connect(function()
        particle:Destroy()
    end)
end

-- Gerar part√≠culas
local particleConnection = RunService.Heartbeat:Connect(function()
    if math.random(1, 30) == 1 then
        createParticle()
    end
end)

-- Anima√ß√µes de entrada
local fadeInTween = TweenService:Create(
    mainFrame,
    TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
    {BackgroundTransparency = 0}
)

local textFadeIn = TweenService:Create(
    titleLabel,
    TweenInfo.new(1.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
    {
        TextTransparency = 0,
        Position = UDim2.new(0.5, -300, 0.5, -50)
    }
)

titleLabel.TextTransparency = 1
titleLabel.Position = UDim2.new(0.5, -300, 0.7, -50)

fadeInTween:Play()
textFadeIn:Play()
gradientTween:Play()

-- Anima√ß√£o de sa√≠da ap√≥s 5 segundos
wait(5)

particleConnection:Disconnect()
gradientTween:Pause()

local fadeOutTween = TweenService:Create(
    mainFrame,
    TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
    {BackgroundTransparency = 1}
)

local textFadeOut = TweenService:Create(
    titleLabel,
    TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
    {
        TextTransparency = 1,
        Position = UDim2.new(0.5, -300, 0.3, -50)
    }
)

fadeOutTween:Play()
textFadeOut:Play()

fadeOutTween.Completed:Connect(function()
    screenGui:Destroy()
end)

print("Bridge Hub MM2 - Parte 1 completa! Carregando interface principal...")

-- Aguardar a GUI desaparecer antes de continuar
wait(1.5)

-- Bridge Hub MM2 Complete Script - PARTE 2
-- Rayfield UI + Vari√°veis Globais + Fun√ß√µes Base (Hitbox, ESP, Aimbot)

-- Carregar Rayfield UI Library
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Servi√ßos do Roblox
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")

-- Player Local
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Camera = Workspace.CurrentCamera

-- ====================================
-- VARI√ÅVEIS GLOBAIS
-- ====================================

-- Anti-Hacker & Detector
local detectorEnabled = false
local antiHackerEnabled = false
local maxNormalSpeed = 23
local detectedHackers = {}
local platform = nil
local connection = nil

-- Anti-Hacker V2 (Detec√ß√£o de Voo)
local autoKnifeEnabled = false
local airTimeThreshold = 3
local playerAirTime = {}

-- ESP & Aimbot
local ESPEnabled = false
local AimbotEnabled = false
local AutoShootEnabled = false
local PingPredictionEnabled = false
local PingMS = 100
local FOVRadius = 100
local targetPlayer = nil
local espConnections = {}
local fovCircle = nil
local aimButton = nil
local ShootType = "Normal"

-- Hitbox
local hitboxEnabled = false
local hitboxSize = 5
local hitboxTransparency = 0.8
local connections = {}
local hitboxParts = {}

-- Player
local speedEnabled = false
local playerSpeed = 16

-- Knife
local autoKillEnabled = false

-- Spectator
local originalCFrame = Camera.CFrame
local isSpectating = false
local currentPlayerIndex = 1
local spectatingConnection
local playersToSpectate = {}
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

local playerNameGui
local leftButton
local rightButton
local exitButton

-- ====================================
-- CRIAR GUI PRINCIPAL (RAYFIELD)
-- ====================================

local Window = Rayfield:CreateWindow({
    Name = "Assasinos vs xerifos - Bridge Hub",
    LoadingTitle = "Loading Bridge Hub",
    LoadingSubtitle = "by darker9899",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "BridgeHubMM2",
        FileName = "config"
    },
    Discord = {
        Enabled = false
    },
    KeySystem = false
})

-- Criar Tabs
local MainTab = Window:CreateTab("Main", 4483362458)
local HitboxTab = Window:CreateTab("Hitbox", 4483362458)
local TeamTab = Window:CreateTab("Anti enemys + team check", 4483362458)
local AntiHackerTab = Window:CreateTab("üõ°Ô∏è Anti Hacker V2", 4483362458)
local PlayerTab = Window:CreateTab("Player", 4483362458)
local KnifeTab = Window:CreateTab("Knife", 4483362458)

-- ====================================
-- FUN√á√ïES DE HITBOX
-- ====================================

local function createHitbox(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local character = player.Character
    local humanoidRootPart = character.HumanoidRootPart
    
    if hitboxParts[player] then
        hitboxParts[player]:Destroy()
        hitboxParts[player] = nil
    end
    
    local hitbox = Instance.new("Part")
    hitbox.Name = "ExpandedHitbox"
    hitbox.Anchored = true
    hitbox.CanCollide = false
    hitbox.Material = Enum.Material.ForceField
    hitbox.BrickColor = BrickColor.new("Really red")
    hitbox.Transparency = hitboxTransparency
    hitbox.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    hitbox.Shape = Enum.PartType.Ball
    hitbox.TopSurface = Enum.SurfaceType.Smooth
    hitbox.BottomSurface = Enum.SurfaceType.Smooth
    hitbox.Parent = workspace
    
    hitboxParts[player] = hitbox
    
    local connection
    connection = RunService.Heartbeat:Connect(function()
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and hitbox.Parent then
            hitbox.CFrame = player.Character.HumanoidRootPart.CFrame
        else
            connection:Disconnect()
            if hitboxParts[player] == hitbox then
                hitboxParts[player] = nil
            end
        end
    end)
    
    connections[player] = connection
end

local function removeHitbox(player)
    if hitboxParts[player] then
        hitboxParts[player]:Destroy()
        hitboxParts[player] = nil
    end
    if connections[player] then
        connections[player]:Disconnect()
        connections[player] = nil
    end
end

local function updateAllHitboxes()
    if not hitboxEnabled then return end
    
    for player, hitbox in pairs(hitboxParts) do
        if hitbox and hitbox.Parent then
            hitbox.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
            hitbox.Transparency = hitboxTransparency
        end
    end
end

local function enableHitboxes()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            createHitbox(player)
        end
    end
end

local function disableHitboxes()
    for player, _ in pairs(hitboxParts) do
        removeHitbox(player)
    end
end

-- ====================================
-- FUN√á√ïES DE ESP
-- ====================================

local function createESP(player)
    if player == LocalPlayer or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local character = player.Character
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESPHighlight"
    highlight.Adornee = character
    highlight.FillColor = Color3.fromRGB(173, 216, 230)
    highlight.FillTransparency = 0.8
    highlight.OutlineColor = Color3.fromRGB(173, 216, 230)
    highlight.OutlineTransparency = 0
    highlight.Parent = character
    
    return highlight
end

local function removeESP(player)
    if player.Character and player.Character:FindFirstChild("ESPHighlight") then
        player.Character.ESPHighlight:Destroy()
    end
end

local function updateESPColor(player, color)
    if player.Character and player.Character:FindFirstChild("ESPHighlight") then
        local highlight = player.Character.ESPHighlight
        highlight.FillColor = color
        highlight.OutlineColor = color
    end
end

-- ====================================
-- FUN√á√ïES DE AIMBOT
-- ====================================

local function isPlayerInFOV(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local character = player.Character
    local humanoidRootPart = character.HumanoidRootPart
    local screenPos, onScreen = Camera:WorldToViewportPoint(humanoidRootPart.Position)
    
    if not onScreen then
        return false
    end
    
    local centerX, centerY = Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2
    local distance = math.sqrt((screenPos.X - centerX)^2 + (screenPos.Y - centerY)^2)
    
    return distance <= FOVRadius
end

local function getPredictedPosition(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end
    
    local humanoidRootPart = player.Character.HumanoidRootPart
    
    if not PingPredictionEnabled then
        return humanoidRootPart.Position
    end
    
    local velocity = humanoidRootPart.AssemblyLinearVelocity
    
    if velocity.Magnitude < 1 then
        return humanoidRootPart.Position
    end
    
    local predictionTime = PingMS / 1000
    local currentPosition = humanoidRootPart.Position
    local predictedPosition = currentPosition + (velocity * predictionTime)
    
    return predictedPosition
end

local function hasLineOfSight(targetPosition)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local origin = LocalPlayer.Character.HumanoidRootPart.Position
    local direction = (targetPosition - origin).Unit * (targetPosition - origin).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    
    local raycastResult = Workspace:Raycast(origin, direction, raycastParams)
    
    if raycastResult then
        local hit = raycastResult.Instance
        local hitCharacter = hit.Parent
        
        if hitCharacter and hitCharacter:FindFirstChild("Humanoid") then
            local player = Players:GetPlayerFromCharacter(hitCharacter)
            if player and targetPlayer and player == targetPlayer then
                return true
            end
        end
    end
    
    return false
end

local function pullPlayerToPosition(player, position)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(position)
    end
end

local function shootAtPosition(targetPosition)
    local currentTool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if currentTool and currentTool:FindFirstChild("GunServer") and currentTool.GunServer:FindFirstChild("GunStart") then
        local args = {
            [1] = 10,
            [2] = targetPosition
        }
        currentTool.GunServer.GunStart:FireServer(unpack(args))
        return true
    end
    return false
end

local function executeAutoShoot()
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local targetPosition = getPredictedPosition(targetPlayer)
        if not targetPosition then return false end
        
        local currentPosition = targetPlayer.Character.HumanoidRootPart.Position
        if hasLineOfSight(currentPosition) then
            return shootAtPosition(targetPosition)
        end
    end
    return false
end

local function getClosestPlayerInFOV()
    local closestPlayer = nil
    local closestDistance = math.huge
    local centerX, centerY = Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if isPlayerInFOV(player) then
                local screenPos = Camera:WorldToViewportPoint(player.Character.HumanoidRootPart.Position)
                local distance = math.sqrt((screenPos.X - centerX)^2 + (screenPos.Y - centerY)^2)
                
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end
    
    return closestPlayer
end

print("Bridge Hub MM2 - Parte 2 completa! Fun√ß√µes base carregadas...")

-- Bridge Hub MM2 Complete Script - PARTE 3
-- GUI Elements (FOV Circle, Aim Button) + Toggles/Sliders (Main, Hitbox, Player, Knife, Team)

-- ====================================
-- FUN√á√ïES PARA CRIAR GUI ELEMENTS
-- ====================================

-- Fun√ß√£o para criar c√≠rculo FOV
local function createFOVCircle()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "FOVCircleGui"
    screenGui.Parent = CoreGui
    screenGui.ResetOnSpawn = false
    
    local circle = Instance.new("Frame")
    circle.Name = "FOVCircle"
    circle.AnchorPoint = Vector2.new(0.5, 0.5)
    circle.Position = UDim2.new(0.5, 0, 0.5, 0)
    circle.Size = UDim2.new(0, FOVRadius * 2, 0, FOVRadius * 2)
    circle.BackgroundTransparency = 1
    circle.Parent = screenGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = circle
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(255, 255, 255)
    stroke.Thickness = 2
    stroke.Transparency = 0.5
    stroke.Parent = circle
    
    return screenGui
end

-- Fun√ß√£o para criar bot√£o de aim
local function createAimButton()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AimButtonGui"
    screenGui.Parent = CoreGui
    screenGui.ResetOnSpawn = false
    
    local button = Instance.new("TextButton")
    button.Name = "AimButton"
    button.Size = UDim2.new(0, 120, 0, 120)
    button.Position = UDim2.new(1, -140, 0.5, -60)
    button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    button.Text = "AIM"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextScaled = true
    button.Font = Enum.Font.SourceSansBold
    button.Parent = screenGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = button
    
    local dragging = false
    local dragStart = nil
    local startPos = nil
    
    button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = button.Position
        end
    end)
    
    button.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    
    button.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)
    
    button.MouseButton1Click:Connect(function()
        if ShootType == "100% (Grab)" then
            -- Modo Grab: Puxa o jogador e atira
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local myPos = LocalPlayer.Character.HumanoidRootPart.Position
                local pullPos = myPos + (Camera.CFrame.LookVector * 5)
                pullPlayerToPosition(targetPlayer, pullPos)
                wait(0.1)
                local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
                shootAtPosition(targetPosition)
            end
        else
            -- Modo Normal
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local targetPosition = getPredictedPosition(targetPlayer)
                if targetPosition then
                    shootAtPosition(targetPosition)
                end
            end
        end
    end)
    
    return screenGui
end

-- ====================================
-- MAIN TAB - TOGGLES E SLIDERS
-- ====================================

local ESPToggle = MainTab:CreateToggle({
    Name = "Esp",
    CurrentValue = false,
    Flag = "ESP",
    Callback = function(Value)
        ESPEnabled = Value
        
        if ESPEnabled then
            local function updateAllESP()
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer then
                        removeESP(player)
                        createESP(player)
                    end
                end
            end
            
            updateAllESP()
            
            espConnections.ESPUpdateLoop = task.spawn(function()
                while ESPEnabled do
                    wait(2)
                    if ESPEnabled then
                        updateAllESP()
                    end
                end
            end)
            
            espConnections.PlayerAdded = Players.PlayerAdded:Connect(function(player)
                if ESPEnabled then
                    player.CharacterAdded:Connect(function()
                        wait(1)
                        createESP(player)
                    end)
                end
            end)
            
            espConnections.PlayerRemoving = Players.PlayerRemoving:Connect(function(player)
                removeESP(player)
            end)
        else
            for _, player in pairs(Players:GetPlayers()) do
                removeESP(player)
            end
            
            for name, connection in pairs(espConnections) do
                if name == "ESPUpdateLoop" then
                    task.cancel(connection)
                else
                    connection:Disconnect()
                end
            end
            espConnections = {}
        end
    end,
})

local ShootTypeDropdown = MainTab:CreateDropdown({
    Name = "Shoot Type",
    Options = {"Normal", "100% (Grab)"},
    CurrentOption = "Normal",
    Flag = "ShootType",
    Callback = function(Option)
        ShootType = Option
    end,
})

local AimbotToggle = MainTab:CreateToggle({
    Name = "Shoot button + Fov",
    CurrentValue = false,
    Flag = "Aimbot",
    Callback = function(Value)
        AimbotEnabled = Value
        
        if AimbotEnabled then
            fovCircle = createFOVCircle()
            aimButton = createAimButton()
            
            espConnections.AimbotLoop = RunService.Heartbeat:Connect(function()
                if AimbotEnabled and ESPEnabled then
                    local closestPlayer = getClosestPlayerInFOV()
                    
                    for _, player in pairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer then
                            updateESPColor(player, Color3.fromRGB(173, 216, 230))
                        end
                    end
                    
                    if closestPlayer then
                        targetPlayer = closestPlayer
                        updateESPColor(closestPlayer, Color3.fromRGB(255, 0, 0))
                        
                        if AutoShootEnabled and ShootType == "Normal" then
                            executeAutoShoot()
                        end
                    else
                        targetPlayer = nil
                    end
                end
            end)
        else
            if fovCircle then
                fovCircle:Destroy()
                fovCircle = nil
            end
            if aimButton then
                aimButton:Destroy()
                aimButton = nil
            end
            if espConnections.AimbotLoop then
                espConnections.AimbotLoop:Disconnect()
                espConnections.AimbotLoop = nil
            end
            targetPlayer = nil
            
            if ESPEnabled then
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer then
                        updateESPColor(player, Color3.fromRGB(173, 216, 230))
                    end
                end
            end
        end
    end,
})

local PingToggle = MainTab:CreateToggle({
    Name = "Ping Prediction",
    CurrentValue = false,
    Flag = "PingPrediction",
    Callback = function(Value)
        PingPredictionEnabled = Value
    end,
})

local PingSlider = MainTab:CreateSlider({
    Name = "Ping (MS)",
    Range = {50, 200},
    Increment = 5,
    CurrentValue = 100,
    Flag = "PingMS",
    Callback = function(Value)
        PingMS = Value
    end,
})

local AutoShootToggle = MainTab:CreateToggle({
    Name = "Auto Shoot (Only Normal Mode)",
    CurrentValue = false,
    Flag = "AutoShoot",
    Callback = function(Value)
        AutoShootEnabled = Value
    end,
})

local FOVSlider = MainTab:CreateSlider({
    Name = "Fov Size",
    Range = {50, 300},
    Increment = 10,
    CurrentValue = 100,
    Flag = "FOVSize",
    Callback = function(Value)
        FOVRadius = Value
        
        if fovCircle and fovCircle:FindFirstChild("FOVCircle") then
            fovCircle.FOVCircle.Size = UDim2.new(0, FOVRadius * 2, 0, FOVRadius * 2)
        end
    end,
})

-- ====================================
-- HITBOX TAB - TOGGLES E SLIDERS
-- ====================================

local HitboxToggle = HitboxTab:CreateToggle({
    Name = "Enable Expanded Hitbox",
    CurrentValue = false,
    Flag = "HitboxToggle",
    Callback = function(Value)
        hitboxEnabled = Value
        if hitboxEnabled then
            enableHitboxes()
        else
            disableHitboxes()
        end
    end,
})

local SizeSlider = HitboxTab:CreateSlider({
    Name = "Hitbox Size",
    Range = {1, 20},
    Increment = 0.5,
    Suffix = " studs",
    CurrentValue = 5,
    Flag = "HitboxSize",
    Callback = function(Value)
        hitboxSize = Value
        updateAllHitboxes()
    end,
})

local TransparencySlider = HitboxTab:CreateSlider({
    Name = "Hitbox Transparency",
    Range = {0, 1},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = 0.8,
    Flag = "HitboxTransparency",
    Callback = function(Value)
        hitboxTransparency = Value
        updateAllHitboxes()
    end,
})

-- ====================================
-- PLAYER TAB - TOGGLES E SLIDERS
-- ====================================

local SpeedToggle = PlayerTab:CreateToggle({
    Name = "Speed Hack",
    CurrentValue = false,
    Flag = "SpeedToggle",
    Callback = function(Value)
        speedEnabled = Value
        if speedEnabled then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.WalkSpeed = playerSpeed
            end
        else
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.WalkSpeed = 16
            end
        end
    end,
})

local SpeedSlider = PlayerTab:CreateSlider({
    Name = "Speed Value",
    Range = {16, 200},
    Increment = 1,
    Suffix = " studs/s",
    CurrentValue = 16,
    Flag = "SpeedValue",
    Callback = function(Value)
        playerSpeed = Value
        if speedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            LocalPlayer.Character.Humanoid.WalkSpeed = playerSpeed
        end
    end,
})

-- ====================================
-- KNIFE TAB - VARI√ÅVEIS & SLIDERS
-- ====================================

local KnifeRange = 7 -- Valor padr√£o inicial

local KnifeRangeSlider = KnifeTab:CreateSlider({
    Name = "Knife Range / Pull Distance",
    Range = {5, 60}, -- De 5 a 60 studs de dist√¢ncia
    Increment = 1,
    Suffix = " studs",
    CurrentValue = 7,
    Flag = "KnifeRange",
    Callback = function(Value)
        KnifeRange = Value
    end,
})

-- ====================================
-- KNIFE TAB - TOGGLES ATUALIZADOS
-- ====================================

local AutoKnifeToggle = KnifeTab:CreateToggle({
    Name = "Auto Knife All Players",
    CurrentValue = false,
    Flag = "AutoKnifeToggle",
    Callback = function(Value)
        autoKnifeEnabled = Value
        
        if autoKnifeEnabled then
            espConnections.AutoKnifeLoop = RunService.Heartbeat:Connect(function()
                if autoKnifeEnabled then
                    local currentTool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
                    
                    -- Verifica se tem tool e personagem vivo
                    if currentTool and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        for _, player in pairs(Players:GetPlayers()) do
                            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                
                                -- L√≥gica de Puxar (Teleporte do inimigo para frente do LocalPlayer)
                                local myPos = LocalPlayer.Character.HumanoidRootPart.Position
                                local lookVector = LocalPlayer.Character.HumanoidRootPart.CFrame.LookVector
                                
                                -- USA A VARI√ÅVEL DO SLIDER AQUI (KnifeRange)
                                local pullPos = myPos + (lookVector * KnifeRange) 
                                pullPlayerToPosition(player, pullPos)
                                
                                -- Hitbox din√¢mica baseada no alcance
                                if player.Character:FindFirstChild("HumanoidRootPart") then
                                    local hrp = player.Character.HumanoidRootPart
                                    if not hrp:FindFirstChild("AutoKnifeHitbox") then
                                        local tempHitbox = Instance.new("Part")
                                        tempHitbox.Name = "AutoKnifeHitbox"
                                        tempHitbox.Anchored = true
                                        tempHitbox.CanCollide = false
                                        tempHitbox.Transparency = 0.7
                                        
                                        -- O tamanho da hitbox acompanha o range (um pouco maior para garantir o hit)
                                        local boxSize = math.clamp(KnifeRange + 2, 5, 20) 
                                        tempHitbox.Size = Vector3.new(boxSize, boxSize, boxSize)
                                        
                                        tempHitbox.Shape = Enum.PartType.Ball
                                        tempHitbox.BrickColor = BrickColor.new("Really red")
                                        tempHitbox.Material = Enum.Material.ForceField
                                        tempHitbox.CFrame = hrp.CFrame
                                        tempHitbox.Parent = workspace
                                        
                                        local hitboxConnection
                                        hitboxConnection = RunService.Heartbeat:Connect(function()
                                            if tempHitbox and tempHitbox.Parent and hrp and hrp.Parent then
                                                tempHitbox.CFrame = hrp.CFrame
                                            else
                                                if tempHitbox then tempHitbox:Destroy() end
                                                hitboxConnection:Disconnect()
                                            end
                                        end)
                                    end
                                end
                                
                                -- Ativa a faca automaticamente se estiver perto
                                if (player.Character.HumanoidRootPart.Position - myPos).Magnitude <= KnifeRange + 5 then
                                    currentTool:Activate()
                                end
                            end
                        end
                    end
                end
            end)
        else
            if espConnections.AutoKnifeLoop then
                espConnections.AutoKnifeLoop:Disconnect()
                espConnections.AutoKnifeLoop = nil
            end
            
            -- Remover todas as hitboxes tempor√°rias ao desligar
            for _, obj in pairs(workspace:GetChildren()) do
                if obj.Name == "AutoKnifeHitbox" then
                    obj:Destroy()
                end
            end
        end
    end,
})

local AutoKillToggle = KnifeTab:CreateToggle({
    Name = "Auto Kill (Click + FOV)",
    CurrentValue = false,
    Flag = "AutoKillToggle",
    Callback = function(Value)
        autoKillEnabled = Value
        
        if autoKillEnabled then
            espConnections.AutoKillInput = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if gameProcessed then return end
                
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    -- Verifica se tem um alvo no FOV (definido pelo script de Aimbot)
                    if autoKillEnabled and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local currentTool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
                        if currentTool then
                            local originalPos = targetPlayer.Character.HumanoidRootPart.CFrame
                            local myPos = LocalPlayer.Character.HumanoidRootPart.Position
                            
                            -- Puxa baseado na dist√¢ncia do slider, mas invertido (traz para perto)
                            -- Aqui usamos um valor fixo pequeno para matar instant√¢neo ou o Range se preferir manter dist√¢ncia
                            local pullPos = myPos + (Camera.CFrame.LookVector * 3) -- Puxa bem perto para garantir o clique
                            
                            pullPlayerToPosition(targetPlayer, pullPos)
                            currentTool:Activate() -- Ativa a faca
                            wait(0.1) 
                            targetPlayer.Character.HumanoidRootPart.CFrame = originalPos -- Devolve o player (efeito ghost)
                        end
                    end
                end
            end)
        else
            if espConnections.AutoKillInput then
                espConnections.AutoKillInput:Disconnect()
                espConnections.AutoKillInput = nil
            end
        end
    end,
})

-- ====================================
-- TEAM TAB - TOGGLE
-- ====================================

local TeamDetectorToggle = TeamTab:CreateToggle({
    Name = "Anti enemys + team check",
    CurrentValue = false,
    Flag = "DetectorToggle",
    Callback = function(Value)
        detectorEnabled = Value
        
        if detectorEnabled then
            connection = RunService.Heartbeat:Connect(function()
                if not detectorEnabled then return end
                
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local localPosition = LocalPlayer.Character.HumanoidRootPart.Position
                    
                    for _, player in pairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            local distance = (player.Character.HumanoidRootPart.Position - localPosition).Magnitude
                            
                            if distance <= 17.5 then
                                local isEnemy = true
                                if player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team then
                                    isEnemy = false
                                end
                                
                                if isEnemy then
                                    local currentCFrame = LocalPlayer.Character.HumanoidRootPart.CFrame
                                    local backwardDirection = -currentCFrame.LookVector
                                    local newPosition = localPosition + (backwardDirection * 1)
                                    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(newPosition, newPosition + currentCFrame.LookVector)
                                    break
                                end
                            end
                        end
                    end
                end
            end)
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end,
})

print("Bridge Hub MM2 - Parte 3 completa! Toggles e Sliders carregados...")

-- Bridge Hub MM2 Complete Script - PARTE 4 (FINAL)
-- Anti-Hacker V2 (Detec√ß√£o de Voo) + Anti-Hacker V1 (Speed) + Event Connections + Finaliza√ß√£o

-- ====================================
-- ANTI-HACKER V2 - DETEC√á√ÉO DE VOO
-- ====================================

local Section = AntiHackerTab:CreateSection("Detec√ß√£o de Voo")

-- Fun√ß√£o para verificar se o personagem est√° no ch√£o
local function isOnGround(character)
    if not character then return true end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not humanoid or not rootPart then return true end
    
    -- Se o humanoid est√° em um estado que indica estar no ch√£o
    if humanoid:GetState() == Enum.HumanoidStateType.Landed or 
       humanoid:GetState() == Enum.HumanoidStateType.Running or
       humanoid:GetState() == Enum.HumanoidStateType.RunningNoPhysics then
        return true
    end
    
    -- Raycast para baixo para verificar se h√° ch√£o pr√≥ximo
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local ray = workspace:Raycast(rootPart.Position, Vector3.new(0, -5, 0), rayParams)
    
    return ray ~= nil
end

-- Fun√ß√£o para teleportar e usar a knife
local function attackFlyingPlayer(targetPlayer)
    if not targetPlayer.Character then return end
    
    local localChar = LocalPlayer.Character
    if not localChar then return end
    
    local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    local localRoot = localChar:FindFirstChild("HumanoidRootPart")
    
    if not targetRoot or not localRoot then return end
    
    -- Teleportar para o jogador
    local originalPosition = localRoot.CFrame
    localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, 3)
    
    wait(0.1)
    
    -- Equipar a 3¬™ tool (knife)
    local backpack = LocalPlayer.Backpack
    local tools = backpack:GetChildren()
    
    if #tools >= 3 then
        local knife = tools[3]
        LocalPlayer.Character.Humanoid:EquipTool(knife)
        
        wait(0.1)
        
        -- Ativar a tool (clicar)
        if knife:IsA("Tool") then
            knife:Activate()
            wait(0.5)
            knife:Activate()
        end
    end
    
    wait(0.5)
    
    -- Voltar para posi√ß√£o original
    localRoot.CFrame = originalPosition
    
    Rayfield:Notify({
       Title = "Hacker Detectado!",
       Content = targetPlayer.Name .. " foi punido por voar!",
       Duration = 3,
       Image = 4483362458,
    })
end

-- Loop de monitoramento de voo
local flyConnection
local FlyToggle = AntiHackerTab:CreateToggle({
    Name = "Auto Knife Hacker (Voo)",
    CurrentValue = false,
    Flag = "AutoKnifeHacker",
    Callback = function(Value)
        autoKnifeEnabled = Value
        
        if Value then
            Rayfield:Notify({
                Title = "Anti-Hacker Ativado",
                Content = "Monitorando jogadores voando...",
                Duration = 3,
                Image = 4483362458,
            })
            
            -- Inicializar tabela de tempo no ar
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    playerAirTime[player.UserId] = 0
                end
            end
            
            flyConnection = RunService.Heartbeat:Connect(function(deltaTime)
                if not autoKnifeEnabled then return end
                
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character then
                        local character = player.Character
                        local humanoid = character:FindFirstChildOfClass("Humanoid")
                        
                        if humanoid and humanoid.Health > 0 then
                            -- Ignorar se o humanoid est√° em estado de pulo normal
                            local state = humanoid:GetState()
                            if state == Enum.HumanoidStateType.Jumping then
                                playerAirTime[player.UserId] = 0
                                continue
                            end
                            
                            if not isOnGround(character) then
                                -- Jogador est√° no ar
                                playerAirTime[player.UserId] = (playerAirTime[player.UserId] or 0) + deltaTime
                                
                                -- Se passou do limite de tempo, considerar como voo
                                if playerAirTime[player.UserId] >= airTimeThreshold then
                                    attackFlyingPlayer(player)
                                    playerAirTime[player.UserId] = 0 -- Reset ap√≥s punir
                                    wait(5) -- Cooldown entre ataques
                                end
                            else
                                -- Jogador est√° no ch√£o, resetar contador
                                playerAirTime[player.UserId] = 0
                            end
                        end
                    end
                end
            end)
            
        else
            if flyConnection then
                flyConnection:Disconnect()
            end
            playerAirTime = {}
            
            Rayfield:Notify({
                Title = "Anti-Hacker Desativado",
                Content = "Monitoramento desligado",
                Duration = 2,
                Image = 4483362458,
            })
        end
    end,
})

-- Slider para ajustar tempo de detec√ß√£o
local AirTimeSlider = AntiHackerTab:CreateSlider({
    Name = "Tempo no Ar (segundos)",
    Range = {1, 5},
    Increment = 0.5,
    CurrentValue = 3,
    Flag = "AirTimeThreshold",
    Callback = function(Value)
        airTimeThreshold = Value
        Rayfield:Notify({
            Title = "Configura√ß√£o Atualizada",
            Content = "Tempo de detec√ß√£o: " .. Value .. "s",
            Duration = 2,
            Image = 4483362458,
        })
    end,
})

local InfoSection = AntiHackerTab:CreateSection("üìã Informa√ß√µes")

local Label = AntiHackerTab:CreateLabel("Sistema detecta jogadores voando por mais de 3s")
local Label2 = AntiHackerTab:CreateLabel("Pulos normais s√£o ignorados automaticamente")
local Label3 = AntiHackerTab:CreateLabel("Teleporta e usa a 3¬™ Tool do invent√°rio")

-- ====================================
-- ANTI-HACKER V1 - DETEC√á√ÉO DE SPEED
-- ====================================

local SpeedSection = AntiHackerTab:CreateSection("Detec√ß√£o de Speed Hack")

local AntiHackerToggle = AntiHackerTab:CreateToggle({
    Name = "Anti-Hacker System (Speed)",
    CurrentValue = false,
    Flag = "AntiHackerToggle",
    Callback = function(Value)
        antiHackerEnabled = Value
        
        if Value then
            connection = RunService.Heartbeat:Connect(function()
                if not antiHackerEnabled then return end
                
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") then
                        local humanoid = player.Character.Humanoid
                        local humanoidRootPart = player.Character.HumanoidRootPart
                        
                        if humanoid.WalkSpeed > maxNormalSpeed or humanoidRootPart.AssemblyLinearVelocity.Magnitude > maxNormalSpeed then
                            Rayfield:Notify({
                                Title = "Hacker Detected",
                                Content = player.Name .. " is speed hacking!",
                                Duration = 3,
                                Image = 4483362458,
                            })
                        end
                    end
                end
            end)
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end,
})

-- ====================================
-- EVENT CONNECTIONS
-- ====================================

-- Quando um novo jogador entra
Players.PlayerAdded:Connect(function(player)
    -- Adicionar √† tabela de tempo no ar
    if autoKnifeEnabled then
        playerAirTime[player.UserId] = 0
    end
    
    -- Criar hitbox se estiver ativado
    if hitboxEnabled and player ~= LocalPlayer then
        player.CharacterAdded:Connect(function()
            wait(1)
            if hitboxEnabled then
                createHitbox(player)
            end
        end)
    end
end)

-- Quando um jogador sai
Players.PlayerRemoving:Connect(function(player)
    removeHitbox(player)
    removeESP(player)
    
    -- Remover da tabela de tempo no ar
    if playerAirTime[player.UserId] then
        playerAirTime[player.UserId] = nil
    end
end)

-- Para todos os jogadores j√° existentes
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function()
            wait(1)
            if hitboxEnabled then
                createHitbox(player)
            end
            if ESPEnabled then
                createESP(player)
            end
        end)
    end
end

-- Quando o personagem local respawna
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    
    if speedEnabled then
        Humanoid.WalkSpeed = playerSpeed
    end
    
    -- Atualizar c√¢mera
    Camera = Workspace.CurrentCamera
end)

-- Limpar quando o personagem for removido
LocalPlayer.CharacterRemoving:Connect(function()
    if flyConnection then
        flyConnection:Disconnect()
    end
    if connection then
        connection:Disconnect()
    end
end)

-- ====================================
-- NOTIFICA√á√ÉO FINAL
-- ====================================

Rayfield:Notify({
    Title = "System Loaded",
    Content = "Bridge Hub loaded successfully!",
    Duration = 5,
    Image = 4483362458,
})

print("Bridge Hub MM2 - Parte 4 completa!")
print("Script totalmente carregado e funcional!")
print("Criado por darker9899")
print("===========================================")
print("‚úÖ Anti-Hacker V2 (Detec√ß√£o de Voo)")
print("‚úÖ Anti-Hacker V1 (Speed Detection)")
print("‚úÖ ESP System")
print("‚úÖ Aimbot + FOV")
print("‚úÖ Hitbox Expander")
print("‚úÖ Auto Knife & Auto Kill")
print("‚úÖ Speed Hack")
print("‚úÖ Team Detector")
print("===========================================")
print("Todas as funcionalidades est√£o ativas!")
